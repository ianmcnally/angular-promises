// Generated by CoffeeScript 1.7.1

/*
angular-promises v0.2.0
Released under the MIT License
By Ian McNally (ia-n.com)
 */

(function() {
  var $q, $timeout, Deferred, Promise, QNotDefinedError, TimeoutNotDefinedError, makeApplyCallback, performDeferredAction,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  $q = null;

  $timeout = null;

  makeApplyCallback = function(action, self) {
    return function() {
      var callback, callbacks, _i, _len, _results;
      callbacks = self["__" + action + "Callbacks__"].slice();
      self["__" + action + "Callbacks__"] = [];
      _results = [];
      for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
        callback = callbacks[_i];
        _results.push(callback.apply(null, arguments));
      }
      return _results;
    };
  };

  Promise = (function() {
    function Promise(__promise__) {
      this.__promise__ = __promise__;
      this.getRawPromise = __bind(this.getRawPromise, this);
      this.progress = __bind(this.progress, this);
      this.always = __bind(this.always, this);
      this.fail = __bind(this.fail, this);
      this.done = __bind(this.done, this);
      this.__doneCallbacks__ = [];
      this.__failCallbacks__ = [];
      this.__alwaysCallbacks__ = [];
      this.__progressCallbacks__ = [];
      this.__promise__.then(makeApplyCallback('done', this), makeApplyCallback('fail', this), makeApplyCallback('progress', this));
      this.__promise__["finally"](makeApplyCallback('always', this));
      this;
    }

    Promise.prototype.done = function(callback) {
      this.__doneCallbacks__.push(callback);
      return this;
    };

    Promise.prototype.fail = function(callback) {
      this.__failCallbacks__.push(callback);
      return this;
    };

    Promise.prototype.always = function(callback) {
      this.__alwaysCallbacks__.push(callback);
      return this;
    };

    Promise.prototype.progress = function(callback) {
      this.__progressCallbacks__.push(callback);
      return this;
    };

    Promise.prototype.getRawPromise = function() {
      return this.__promise__;
    };

    return Promise;

  })();

  QNotDefinedError = (function(_super) {
    __extends(QNotDefinedError, _super);

    function QNotDefinedError() {
      this.name = 'QNotDefinedError';
      this.message = '$q must injected. Did you instantiate Deferred with `new`?';
    }

    return QNotDefinedError;

  })(Error);

  TimeoutNotDefinedError = (function(_super) {
    __extends(TimeoutNotDefinedError, _super);

    function TimeoutNotDefinedError() {
      this.name = 'TimeoutNotDefinedError';
      this.message = '$timeout must injected. Did you instantiate Deferred with `new`?';
    }

    return TimeoutNotDefinedError;

  })(Error);

  performDeferredAction = function(action, calledArguments) {
    return $timeout(((function(_this) {
      return function() {
        return _this.__deferred__[action].apply(_this, calledArguments);
      };
    })(this)), 0);
  };

  Deferred = (function() {

    /*
    Deferred is a wrapper for $q.defer()
    that allows for chaining, ala jQuery.Deferred()
    as well as a similar promise interface,
    with the added benefit of performing
    a $scope.$apply on all promise callbacks,
    to keep them in the angular event loop.
    
    Additionally, Deferred provides two instances methods,
    `all` and `until`, that wrap an array of Deferred promise objects
    and returns a single promise that is fulfilled when all
    the input objects are fulfilled.
     */
    function Deferred() {
      this.promise = __bind(this.promise, this);
      this.notify = __bind(this.notify, this);
      this.reject = __bind(this.reject, this);
      this.resolve = __bind(this.resolve, this);
      if (!$q) {
        throw new QNotDefinedError;
      }
      if (!$timeout) {
        throw new TimeoutNotDefinedError;
      }
      this.__deferred__ = $q.defer();
      this.__promise__ = new Promise(this.__deferred__.promise);
      this;
    }


    /*
    Resolve the Deferred object and call its handler
     */

    Deferred.prototype.resolve = function() {
      performDeferredAction.call(this, 'resolve', arguments);
      return this;
    };


    /*
    Reject the Deferred object and call its handler
     */

    Deferred.prototype.reject = function() {
      performDeferredAction.call(this, 'reject', arguments);
      return this;
    };


    /*
    Call the progress callback on a Deferred object
     */

    Deferred.prototype.notify = function() {
      performDeferredAction.call(this, 'notify', arguments);
      return this;
    };


    /*
    Return the Deferred promise object
     */

    Deferred.prototype.promise = function() {
      return this.__promise__;
    };


    /*
    Returns a single promise, which is fulfilled when all `promises`
    are resolved or rejected.
    
    Note: this is unlike Deferred.until (or $q.all) which rejects immediately
      on a rejected promise.
    
    Params: Array of promises (Deferred().promise() instances)
    
    Returns: promise
     */

    Deferred.all = function(promises) {
      var amtPromises, checkFulfillments, deferred, fulfillments, promise, _i, _len;
      deferred = new Deferred();
      fulfillments = {
        resolved: [],
        rejected: []
      };
      amtPromises = promises.length;
      for (_i = 0, _len = promises.length; _i < _len; _i++) {
        promise = promises[_i];
        if (!(promise instanceof Promise)) {
          throw new InvalidPromiseInstanceError;
        }
        promise.done(function() {
          return fulfillments.resolved.push(promise);
        });
        promise.fail(function() {
          return fulfillments.rejected.push(promise);
        });
      }
      checkFulfillments = function() {
        if (fulfillments.resolved.length + fulfillments.rejected.length !== amtPromises) {
          return $timeout(checkFulfillments, 0);
        } else if (fulfillments.rejected.length) {
          return deferred.reject(fulfillments);
        } else {
          return deferred.resolve(fulfillments);
        }
      };
      checkFulfillments();
      return deferred.promise();
    };


    /*
    Returns a single promise, which is fulfilled when all `promises`
    are resolved or immediately if a promise in `promises` is rejected.
    
    Params: Array of promises - Deferred().promise() instances
    
    Returns: promise
     */

    Deferred.until = function(promises) {
      var deferred, promise, rawPromises;
      deferred = new Deferred();
      rawPromises = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = promises.length; _i < _len; _i++) {
          promise = promises[_i];
          if (!(promise instanceof Promise)) {
            throw new InvalidPromiseInstanceError;
          }
          _results.push(promise.__promise__);
        }
        return _results;
      })();
      $q.all(promises).then(deferred.resolve, deferred.reject);
      return deferred.promise();
    };

    return Deferred;

  })();

  angular.module('angular-promises', []).factory('Deferred', [
    '$q', '$timeout', function(_$q_, _$timeout_) {
      $q = _$q_;
      $timeout = _$timeout_;
      return Deferred;
    }
  ]);

}).call(this);
